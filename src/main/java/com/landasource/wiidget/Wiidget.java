package com.landasource.wiidget;

import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.apache.commons.io.IOUtils;

import com.landasource.wiidget.engine.Engine;
import com.landasource.wiidget.io.BufferedPrintStream;
import com.landasource.wiidget.io.FileLoader;
import com.landasource.wiidget.util.DataMap;

/**
 * The base class behind all wiidget. A wiidget acts as a puzzle piece in the
 * template hierarchy. It has two methods that are important for the outer
 * world:
 * <ol>
 * <li>{@link #init()} This is called after the wiidget is constructed
 * attributes/properties are set and the optional dependencies are satisfied.
 * Here you can start a buffer with {@link #startBuffer()} (see later)</li>
 * <li>{@link #run()} This is called after all children is rendered and
 * processed. Therefore the children are accessible with {@link #getChildren()}
 * or just single {@link #getChild(Class)}. When you want to getall children
 * with the type call {@link #getChildren(Class)}. When the wiidget has started
 * buffer the content of the buffer is ready to flush and read. Just call
 * {@link #endBuffer()}</li>
 * </ol>
 *
 * @author Zsolt Lengyel (zsolt.lengyel.it@gmail.com)
 * @since 0.1
 */
public abstract class Wiidget {

	/** Empty data map. Just for avoid unnecessary constructions */
	@SuppressWarnings("unchecked")
	public static final Map<String, Object> EMPTY_DATA = Collections
	.unmodifiableMap(Collections.EMPTY_MAP);

	/**
	 * Unique ID of wiidget. Generated by {@link #getId()} when the method is
	 * called or set explicitly by developer.
	 */
	protected String id;

	/** Rendered property. By default every widget is rendered. */
	private boolean rendered = true;

	/** Owner/parent of the current wiidget. */
	private WiidgetView owner;

	/** Children are stored in this linked list. */
	private final List<Wiidget> children = new LinkedList<Wiidget>();

	/**
	 * This method called after all the attributes setted succesfully.
	 */
	public void init() {
	}

	/**
	 * This method is invoked, when all the children's run method has invoked.
	 */
	public void run() {
	}

	/**
	 * This method is called, when the lang processor did not find the field in
	 * the class.
	 *
	 * @param name
	 *            name of the field
	 * @param value
	 *            value of the field.
	 */
	public void setAttribute(final String name, final Object value) {
		throw new WiidgetException(String.format(
				"%s has no field with name: %s", getClass().getCanonicalName(),
				name));
	}

	protected <W extends Wiidget> W beginWiidget(final W wiidget) {
		getEngine().addWiidget(wiidget, getOwner(), true);

		if (wiidget.isRendered()) {
			wiidget.init();

			return wiidget;
		}
		// the wiidget is not rendered
		return null;
	}

	protected <W extends Wiidget> W wiidget(final Class<W> widgetClass) {
		return wiidget(widgetClass, EMPTY_DATA);
	}

	protected <W extends Wiidget> W wiidget(final Class<W> widgetClass,
			final Map<String, Object> dataMap) {
		final W widget = getEngine().createWiidget(getOwner(), widgetClass,
				dataMap, false);

		if (widget.isRendered()) {
			widget.init();
			widget.run();

			return widget;

		}

		// the wiidget is not rendered
		return null;
	}

	/**
	 * Creates instance of specified type.
	 *
	 * @param widgetClass
	 *            type of the wiidget
	 * @return instance of the wiidget when it is rendered
	 */
	protected <W extends Wiidget> W beginWiidget(final Class<W> widgetClass) {
		return beginWiidget(widgetClass, EMPTY_DATA);
	}

	/**
	 * Creates instance of specified type.
	 *
	 * @param widgetClass
	 *            type of the wiidget
	 * @param dataMap
	 *            attributes map
	 * @return instance of the wiidget when it is rendered
	 */
	protected <W extends Wiidget> W beginWiidget(final Class<W> widgetClass,
			final Map<String, Object> dataMap) {
		final W widget = getEngine().createWiidget(getOwner(), widgetClass,
				dataMap, true);

		if (widget.isRendered()) {
			widget.init();

			return widget;
		}
		// the wiidget is not rendered
		return null;
	}

	/**
	 * @param wiidget
	 *            wiidget to start
	 * @return the wiidget when its rendered. Otherwise null
	 */
	protected <W extends Wiidget> W startWiidget(final W wiidget) {
		if (wiidget.isRendered()) { // the wiidget can decide about itself be
			// rendered before initialised

			wiidget.init(); // call init method

			return wiidget;
		}
		// the wiidget is not rendered
		return null;
	}


	/**
	 * @return closes the current wiidget
	 */
	@SuppressWarnings("unchecked")
	protected <W extends Wiidget> W endWiidget() {
		final Wiidget wiidget = getEngine().getWiidgetStack().pop();

		if (wiidget.isRendered()) {
			wiidget.run();
		}

		return (W) wiidget;
	}

	/**
	 * Ends the wiidget. Similar to {@link #endWiidget()} but checks the reference to enforce document validity.
	 * @param wiidget the current wiidget
	 * @return the closed wiidget
	 */
	protected <W extends Wiidget> W endWiidget(final W wiidget) {

		Wiidget closedWiidget = endWiidget();

		if (wiidget != closedWiidget) { // wiidget must be the same (by reference)
			throw new WiidgetException(
					"Run specified widget failed. Maybe there is another unclosed wiidget.");
		}

		return wiidget;
	}

	@SuppressWarnings("unchecked")
	protected <W extends Wiidget> W endWiidget(final Class<W> widgetClass) {

		Wiidget closedWiidget = endWiidget();


		if (!widgetClass.isAssignableFrom(closedWiidget.getClass())) {
			throw new WiidgetException(
					"Run specified widget failed. Maybe there is another unclosed widget.");
		}

		return (W) closedWiidget;
	}

	/**
	 * @return the parent of the wiidget. Can be null in some case. E.g. when wiidget is a view.
	 */
	public WiidgetView getOwner() {
		return this.owner;
	}

	/**
	 *
	 * @param owner owner of the wiidget. Called by the engine but in some special case can be useful to change the owner
	 */
	public void setOwner(final WiidgetView owner) {
		this.owner = owner;
	}

	/**
	 *
	 * @return children of this wiidget
	 */
	public List<Wiidget> getChildren() {
		return children;
	}

	/**
	 *
	 * @param wiidgetClass type of child wiidgets must be present in the result
	 * @return children with the specified type
	 */
	@SuppressWarnings("unchecked")
	public <W> List<W> getChildren(final Class<W> wiidgetClass) {

		final List<W> childrenWithType = new LinkedList<W>();

		for (final Wiidget child : getChildren()) {

			if (wiidgetClass.isAssignableFrom(child.getClass())) {

				childrenWithType.add((W) child);
			}
		}

		return childrenWithType;
	}

	/**
	 * @param wiidgetClass type of child
	 * @return the only one child with the type
	 * @throws WiidgetException when there are more then one children with the specified type
	 */
	public <W> W getChild(final Class<W> wiidgetClass) {

		final List<W> children = getChildren(wiidgetClass);

		if (children.size() > 1) {
			throw new WiidgetException(
					"The wiidget has more than one children with type: "
							+ wiidgetClass.getCanonicalName());
		}

		if (children.isEmpty()) {
			return null;
		}
		return children.get(0);
	}

	/**
	 * @param wiidgetClass type of children
	 * @see #getChildren(Class)
	 * @return list of direct and indirect children with the given type
	 */
	@SuppressWarnings("unchecked")
	public <W> W getChildRecursive(final Class<W> wiidgetClass) {

		final List<Wiidget> children = getChildren();
		for (final Wiidget child : children) {

			// return the first match
			if (wiidgetClass.isAssignableFrom(child.getClass())) {
				return (W) child;
			}

			final W fromChild = child.getChildRecursive(wiidgetClass);
			if (null != fromChild) {
				return fromChild;
			}
		}

		return null;
	}

	/**
	 * Start the buffer. The content and result of childen will be collected in a new buffer which is stacked upon the previous buffers.
	 */
	protected void startBuffer() {
		getPrintStream().startBuffer();
	}

	/**
	 *
	 * @return flushes the buffer and pops from stack. Returns the content of the popped buffer.
	 */
	protected String endBuffer() {
		return getPrintStream().endBuffer();
	}

	/**
	 * Returns the content of the specified file.
	 *
	 * @param path
	 *            path of the template
	 * @return content of the file
	 * @see FileLoader
	 */
	protected String getFileContent(final String path) {
		if (null == path) {
			throw new WiidgetException("File path cannot be null.");
		}

		String content = "";

		try {

			final FileLoader fileLoader = getEngine().getConfiguration()
					.getFileLoader();
			final InputStream file = fileLoader.getFile(path);

			if (file == null) {
				throw new WiidgetException("Cannot found file: " + path);
			}

			content = IOUtils.toString(file);

		} catch (final IOException exception) {

			throw new WiidgetException("Cannot read file: " + path, exception);
		}

		return content;
	}



	protected void write(final String string) {
		getPrintStream().write(string);
	}

	protected void write(final Object object) {
		write(object.toString());
	}

	protected BufferedPrintStream getPrintStream() {
		return getOwner().getPrintStream();
	}

	protected Engine getEngine() {
		return getOwner().getEngine();
	}

	protected DataMap data() {
		return new DataMap();
	}

	public String getId() {

		if (null == this.id) {
			final String uniqueId = getEngine().getUniqueId();
			this.setId(uniqueId);
		}

		return id;
	}

	/**
	 *
	 * @param id explicitly sets the id of this wiidget
	 */
	public void setId(final String id) {
		this.id = id;
	}

	/**
	 *
	 * @return true when wiidget is rendered
	 */
	public boolean isRendered() {
		return rendered;
	}

	/**
	 *
	 * @param rendered attribute setter
	 */
	public void setRendered(final boolean rendered) {
		this.rendered = rendered;
	}

}
